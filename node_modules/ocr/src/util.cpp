#include <type_traits>
#include <map>
#include <string>
#include <nan.h>
#include "ocrxpress.h"
#include "util.h"

namespace ocrxpress {
	// These conversion maps are defined at the end of this file
	extern const std::map<std::string, OCRX_Language> convertStringToLanguage;
	extern const std::map<std::string, OCRX_FileMode> convertStringToFileMode;
	extern const std::map<std::string, OCRX_FileFormat> convertStringToFileFormat;
	extern const std::map<std::string, OCRX_PageOrientation> convertStringToPageOrientation;

	// Checks if an error has occurred with the OCRX engine
	bool isOcrxError(OCRX_Status status) {
		return status.StatusCode == OCRX_StatusCode_Error;
	}

	ErrorType createError(const std::string &errorMessage) {
		return Nan::Error(errorMessage.c_str());
	}

	ErrorType createError(const std::string &errorContext, OCRX_Status status) {
		auto errorString = errorContext + " -- (" + status.ErrorCode + ") " + status.ErrorDetails;
		return Nan::Error(errorString.c_str());
	}

	// Gets an array of the descendant objects of the specified result type.
	// The returned results will also depend on the calling type. For example if getCharacters is called from a document,
	// then all the characters from the entire document will be retrieved. If getCharacters is called from a word, then only the characters in the word will be retrieved.
	template<OCRX_ResultType descendantResultType>
	NAN_METHOD(fillDescendantResults) {
		auto caller = (info.Holder());
		auto callerResultInfo = (ResultObjectInfo*)(Nan::GetInternalFieldPointer(caller, 0));

		OCRX_Status status;
		int32_t numDescendantResults;
		auto resultArray = Nan::New<v8::Array>();
		status = OCRX_get_descendant_result_count(callerResultInfo->result, descendantResultType, &numDescendantResults);
		if(isOcrxError(status)) {
			Nan::ThrowError( createError("Error getting descendant result count from ocr engine", status) );
			return;
		}

		for (int i = 0; i < numDescendantResults; i++) {
			// Get the current result from the ocrxpress library:
			OCRX_Result descendantResult;
			status = OCRX_get_descendant_result(callerResultInfo->result, descendantResultType, i, &descendantResult);
			if(isOcrxError(status)) {
				Nan::ThrowError( createError("Error getting descendant result from ocr engine", status) );
				return;
			}

			// Create new JS object with the current result and fill it
			auto obj = Nan::New<v8::ObjectTemplate>(resultClass)->NewInstance();
			fillResultObject(callerResultInfo->refCount, obj, descendantResult, descendantResultType);
			Nan::Set(resultArray, i, obj);
		}

		info.GetReturnValue().Set(resultArray);
	}

	// This function is called whenever one of the ResultObjects are cleaned up in the garbage collection
	static void cleanupResultObject(const Nan::WeakCallbackInfo<ResultObjectInfo> &info) {
		auto *ri = info.GetParameter();
		if(ri == nullptr) return;

		(*ri->refCount)--;
		if(*ri->refCount <= 0) {
			OCRX_free_document_result(&ri->result); //free the root document in OCRX
			delete ri->refCount;
		}
		delete ri;
	}

	void fillResultObject(int *refCount, const v8::Local<v8::Object>& resultObject, const OCRX_Result result, const OCRX_ResultType resultType) {
		Nan::HandleScope scope;

		// Create the intial reference counting value
		if(refCount == nullptr) refCount = new int(0);

		// Create the internal c++ structure that will handle garbage collection details
		auto ri = new ResultObjectInfo();
		ri->resultObject.Reset(resultObject);
		ri->result = result;
		ri->resultType = resultType;
		ri->refCount = refCount;
		Nan::SetInternalFieldPointer(resultObject, 0, ri);

		// Enable the garbage collection call
		(*ri->refCount)++;
		ri->resultObject.SetWeak(ri, cleanupResultObject, Nan::WeakCallbackType::kParameter);

		// Fill the data fields for the resultObject
		OCRX_Status status;

		// Get the result text
		int textSize;
		char *textBuffer;
		status = OCRX_get_utf8_text_size(result, &textSize);
		textBuffer = new char[textSize+1];
		status = OCRX_get_utf8_text(result, textBuffer, textSize);
		if(isOcrxError(status)) {
			Nan::ThrowError( createError("fillResultObject: Error getting text", status) );
			return;
		}
		Nan::Set(resultObject, Nan::New("text").ToLocalChecked(), Nan::New(textBuffer).ToLocalChecked());
		delete [] textBuffer;

		// Set area - every result except for document will have one
		if (resultType != OCRX_ResultType_Document) {
			OCRX_Rectangle resultArea;
			status = OCRX_get_area(result, &resultArea);
			if(isOcrxError(status)) {
				Nan::ThrowError( createError("fillResultObject: Error getting area", status) );
				return;
			}
			auto area = Nan::New<v8::Object>();
			Nan::Set(area, Nan::New("x").ToLocalChecked(), Nan::New<v8::Integer>(resultArea.Left));
			Nan::Set(area, Nan::New("y").ToLocalChecked(), Nan::New<v8::Integer>(resultArea.Top));
			Nan::Set(area, Nan::New("width").ToLocalChecked(), Nan::New<v8::Integer>(resultArea.Right - resultArea.Left));
			Nan::Set(area, Nan::New("height").ToLocalChecked(), Nan::New<v8::Integer>(resultArea.Bottom - resultArea.Top));
			Nan::Set(resultObject, Nan::New("area").ToLocalChecked(), area);
		}

		// Set the orientation - only valid for a page:
		if (resultType == OCRX_ResultType_Page) {
			int orientation;
			status = OCRX_get_orientation(result, &orientation);
			if(isOcrxError(status)) {
				Nan::ThrowError( createError("fillResultObject: Error getting orientation", status) );
				return;
			}
			Nan::Set(resultObject, Nan::New("orientation").ToLocalChecked(), Nan::New<v8::Integer>(orientation));
		}

		// Set the confidence - only valid for a character
		if (resultType == OCRX_ResultType_Character) {
			int conf;
			status = OCRX_get_confidence(result, &conf);
			if(isOcrxError(status)) {
				Nan::ThrowError( createError("fillResultObject: Error getting confidence", status) );
			}
			Nan::Set(resultObject, Nan::New("confidence").ToLocalChecked(), Nan::New<v8::Integer>(conf));
		}

		// Create the accessor methods for the descendant results:
		switch( resultType ) {
		case OCRX_ResultType_Document:
			Nan::SetMethod(resultObject, "getPages", fillDescendantResults<OCRX_ResultType_Page>);
		case OCRX_ResultType_Page:
			Nan::SetMethod(resultObject, "getRegions", fillDescendantResults<OCRX_ResultType_Region>);
		case OCRX_ResultType_Region:
			Nan::SetMethod(resultObject, "getTextBlocks", fillDescendantResults<OCRX_ResultType_TextBlock>);
		case OCRX_ResultType_TextBlock:
			Nan::SetMethod(resultObject, "getTextLines", fillDescendantResults<OCRX_ResultType_TextLine>);
		case OCRX_ResultType_TextLine:
			Nan::SetMethod(resultObject, "getWords", fillDescendantResults<OCRX_ResultType_Word>);
		case OCRX_ResultType_Word:
			Nan::SetMethod(resultObject, "getCharacters", fillDescendantResults<OCRX_ResultType_Character>);
		default: break;
		}
	}

	std::string getField(v8::Local<v8::Object> obj, const char *fieldName, const std::string &defaultValue) {
		Nan::HandleScope scope;

		auto field = Nan::New(fieldName).ToLocalChecked();

		if (false == Nan::Has(obj, field).FromJust())
			return defaultValue;

		return std::string(*Nan::Utf8String(Nan::Get(obj, field).ToLocalChecked()));
	}

	int getField(v8::Local<v8::Object> obj, const char *fieldName, const int defaultValue) {
		Nan::HandleScope scope;

		auto field = Nan::New(fieldName).ToLocalChecked();

		if (false == Nan::Has(obj, field).FromJust())
			return defaultValue;

		return Nan::Get(obj, field).ToLocalChecked()->Int32Value();
	}

	//a set of templated functions to convert enum values to strings
	template<typename Type>
	std::string getStringValue(typename std::enable_if<std::is_enum<Type>::value, const Type>::type &t) {
		return std::to_string(t);
	}

	template<typename Type>
	std::string getStringValue(typename std::enable_if<!std::is_enum<Type>::value, const Type>::type &t) {
		return t;
	}

	//a function for converting between types:
	template<typename From, typename To>
	bool convertProperty(const From &from, To& to, ErrorType &error, const std::map<From,To> &choices) {
		const auto iter = choices.find(from);
		if(iter == choices.end()) {
			//can't find the value we're converting from:
			error = createError(std::string("convertProperty: Invalid conversion parameter '") + getStringValue<From>(from) + "'");
			return true;
		}
		to = iter->second;
		return false;
	}

	//a set of template functions to convert between types:
	template<> bool convertProperty<char*, OCRX_Language>(char* const& from, OCRX_Language& to, ErrorType& error) {
		return convertProperty(std::string(from), to, error, convertStringToLanguage);
	}

	template<> bool convertProperty<char*, OCRX_PageOrientation>(char* const& from, OCRX_PageOrientation& to, ErrorType& error) {
		return convertProperty(std::string(from), to, error, convertStringToPageOrientation);
	}

	template<> bool convertProperty<char*, OCRX_FileMode>(char* const& from, OCRX_FileMode& to, ErrorType& error) {
		return convertProperty(std::string(from), to, error, convertStringToFileMode);
	}

	template<> bool convertProperty<char*, OCRX_FileFormat>(char* const& from, OCRX_FileFormat& to, ErrorType& error) {
		return convertProperty(std::string(from), to, error, convertStringToFileFormat);
	}

	//retrieve a string property from the object
	// then try to convert from the string to enum type and return an error is one occurs.
	template<typename Type>
	bool getProperty(v8::Local<v8::Object> obj, const char* paramName, Type& retParam, ErrorType& error) {
		Nan::EscapableHandleScope scope;
		auto fieldName = Nan::New(paramName).ToLocalChecked();
		if (false == Nan::Has(obj, fieldName).FromJust()) return false;

		auto param = Nan::Get(obj, fieldName).ToLocalChecked();
		bool result = convertProperty(*Nan::Utf8String(param), retParam, error);
		error = scope.Escape(error);
		return result;
	}

	template bool getProperty(v8::Local<v8::Object>, const char*, OCRX_Language&, ErrorType&);
	template bool getProperty(v8::Local<v8::Object>, const char*, OCRX_FileMode&, ErrorType&);
	template bool getProperty(v8::Local<v8::Object>, const char*, OCRX_FileFormat&, ErrorType&);
	template bool getProperty(v8::Local<v8::Object>, const char*, OCRX_PageOrientation&, ErrorType&);

	template <>
	bool getProperty<std::string>(v8::Local<v8::Object> obj, const char* inputParam, std::string& retParam) {
		Nan::HandleScope scope;
		auto fieldName = Nan::New(inputParam).ToLocalChecked();
		if (false == Nan::Has(obj, fieldName).FromJust()) return false;
		auto param = Nan::Get(obj, fieldName).ToLocalChecked();
		retParam = std::string(*Nan::Utf8String(param));
		return false;
	}

	const std::map<std::string, OCRX_Language> initializeLanguageMap() {
		std::map<std::string, OCRX_Language> result;
		result["english"] = OCRX_Language_English;
		result["arabic"] = OCRX_Language_Arabic;
		result["bulgarian"] = OCRX_Language_Bulgarian;
		result["catalan"] = OCRX_Language_Catalan;
		result["chinese simplified"] = OCRX_Language_Chinese_Simplified;
		result["chinese traditional"] = OCRX_Language_Chinese_Traditional;
		result["croatian"] = OCRX_Language_Croatian;
		result["czech"] = OCRX_Language_Czech;
		result["danish"] = OCRX_Language_Danish;
		result["danish fraktur"] = OCRX_Language_Danish_Fraktur;
		result["dutch"] = OCRX_Language_Dutch;
		result["german"] = OCRX_Language_German;
		result["german fraktur"] = OCRX_Language_German_Fraktur;
		result["greek"] = OCRX_Language_Greek;
		result["finnish"] = OCRX_Language_Finnish;
		result["french"] = OCRX_Language_French;
		result["hebrew"] = OCRX_Language_Hebrew;
		result["hindi"] = OCRX_Language_Hindi;
		result["hungarian"] = OCRX_Language_Hungarian;
		result["indonesian"] = OCRX_Language_Indonesian;
		result["italian"] = OCRX_Language_Italian;
		result["japanese"] = OCRX_Language_Japanese;
		result["korean"] = OCRX_Language_Korean;
		result["latvian"] = OCRX_Language_Latvian;
		result["lithuanian"] = OCRX_Language_Lithuanian;
		result["norwegian"] =OCRX_Language_Norwegian;
		result["polish"] = OCRX_Language_Polish;
		result["portugese"] = OCRX_Language_Portuguese;
		result["romanian"] = OCRX_Language_Romanian;
		result["russian"] = OCRX_Language_Russian;
		result["serbian"] = OCRX_Language_Serbian;
		result["slovak"] = OCRX_Language_Slovak;
		result["slovak fraktur"] = OCRX_Language_Slovak_Fraktur;
		result["slovenian"] = OCRX_Language_Slovenian;
		result["spanish"] = OCRX_Language_Spanish;
		result["swedish"] = OCRX_Language_Swedish;
		result["tagalog"] = OCRX_Language_Tagalog;
		result["thai"] = OCRX_Language_Thai;
		result["turkish"] = OCRX_Language_Turkish;
		result["ukrainian"] = OCRX_Language_Ukrainian;
		result["vietnamese"] = OCRX_Language_Vietnamese;
		return result;
	}
	const std::map<std::string, OCRX_Language> convertStringToLanguage = initializeLanguageMap();

	const std::map<std::string, OCRX_FileFormat> initializeFileFormatMap() {
		std::map<std::string, OCRX_FileFormat> result;
		result["pdf"]  = OCRX_FileFormat_PDF;
		result["PDF"]  = OCRX_FileFormat_PDF;
		result["text"] = OCRX_FileFormat_Text;
		result["txt"]  = OCRX_FileFormat_Text;
		return result;
	}
	const std::map<std::string, OCRX_FileFormat> convertStringToFileFormat = initializeFileFormatMap();

	const std::map<std::string, OCRX_FileMode> initializeFileModeMap() {
		std::map<std::string, OCRX_FileMode> result;
		result["append"]    = OCRX_FileMode_Append;
		result["overwrite"] = OCRX_FileMode_Overwrite;
		return result;
	}
	const std::map<std::string, OCRX_FileMode> convertStringToFileMode = initializeFileModeMap();

	const std::map<std::string, OCRX_PageOrientation> initializePageOrientationMap() {
		std::map<std::string, OCRX_PageOrientation> result;
		result["auto"]     = OCRX_PageOrientation_Detect;
		result["detect"]   = OCRX_PageOrientation_Detect;
		result["reorient"] = OCRX_PageOrientation_Reorient;
		result["upright"]  = OCRX_PageOrientation_Upright;
		return result;
	}
	const std::map<std::string, OCRX_PageOrientation> convertStringToPageOrientation = initializePageOrientationMap();
}
