#include <node.h>
#include <nan.h>
#include <string>
#include <map>

#include "util.h"
#include "asyncworkers.h"

namespace ocrxpress {
	Nan::Persistent<v8::ObjectTemplate> libSymbolsClass;
	Nan::Persistent<v8::ObjectTemplate> resultClass;

	NAN_METHOD(setSolutionName) {
		Nan::Utf8String name(Nan::To<v8::String>(info[0]).ToLocalChecked());

		OCRX_Status status = OCRX_set_solution_name(*name);
		if(isOcrxError(status)) Nan::ThrowError(createError("OCRX setSolutionName", status));
	}

	NAN_METHOD(setSolutionKey) {
		auto key1 = info[0]->Int32Value();
		auto key2 = info[1]->Int32Value();
		auto key3 = info[2]->Int32Value();
		auto key4 = info[3]->Int32Value();

		OCRX_Status status = OCRX_set_solution_key(key1, key2, key3, key4);
		if(isOcrxError(status)) Nan::ThrowError(createError("OCRX setSolutionKey", status));
	}

	NAN_METHOD(setOemLicenseKey) {
		Nan::Utf8String key(Nan::To<v8::String>(info[0]).ToLocalChecked());

		OCRX_Status status = OCRX_set_oem_license_key(*key);
		if(isOcrxError(status)) Nan::ThrowError(createError("OCRX setOemLicenseKey", status));
	}

	NAN_METHOD(recognize) {
		auto params = Nan::To<v8::Object>(info[0]).ToLocalChecked();
		auto callback = new Nan::Callback(info[1].As<v8::Function>());

		ErrorType error;
		OCRX_FileMode fileMode = OCRX_FileMode_Overwrite; // set default value
		OCRX_FileFormat fileFormat = OCRX_FileFormat_PDF; // set default value
		OCRX_RecognitionParameters recognitionParameters = OCRX_DefaultRecognitionParameters;
		if( getProperty(params, "language", recognitionParameters.Language, error) ||
		    getProperty(params, "orientation", recognitionParameters.PageOrientation, error) ||
		    getProperty(params, "mode", fileMode, error) ||
		    getProperty(params, "format", fileFormat, error))
			{
				v8::Local<v8::Value> argv[] = { error };
				callback->Call(1, argv);
				delete callback;
				return;
			}

		// Calculate the default DPI values
		auto dpiString = Nan::New("defaultDpi").ToLocalChecked();
		if ( true == Nan::Has(params, dpiString).FromJust() ) {
			auto dpiArray = Nan::To<v8::Object>( Nan::Get(params, dpiString).ToLocalChecked() ).ToLocalChecked();
			recognitionParameters.DefaultXDPI = Nan::Get(dpiArray, 0).ToLocalChecked()->Int32Value();
			recognitionParameters.DefaultYDPI = Nan::Get(dpiArray, 1).ToLocalChecked()->Int32Value();
		}

		std::string inputFile = getField(params, "input", "");
		std::string outputFile = getField(params, "output", "");

		OCRX_Result parentDocument = 0;
		int *parentRefCount = nullptr;
		auto docString = Nan::New("document").ToLocalChecked();
		if( true == Nan::Has(params, docString).FromJust() ) {
			auto documentObject = Nan::To<v8::Object>( Nan::Get(params, docString).ToLocalChecked() ).ToLocalChecked();

			// Check that the InternalFieldPointer count is exactly 1
			if(1 != documentObject->InternalFieldCount()) {
				error = createError(std::string("OCRX recognize: Invalid document parameter."));
				v8::Local<v8::Value> argv[] = { error };
				callback->Call(1, argv);
				delete callback;
				return;
			}

			auto callerResultInfo = (ResultObjectInfo*)(Nan::GetInternalFieldPointer(documentObject, 0));
			parentDocument = callerResultInfo->result;
			parentRefCount = callerResultInfo->refCount;
		}

		Nan::AsyncQueueWorker(new RecognizeWorker(&recognitionParameters, inputFile, fileFormat, fileMode, outputFile, parentDocument, parentRefCount, callback));

	}

	NAN_MODULE_INIT(Init) {
		auto lsc = Nan::New<v8::ObjectTemplate>();
		libSymbolsClass.Reset(lsc);
		lsc->SetInternalFieldCount(1);

		auto dc = Nan::New<v8::ObjectTemplate>();
		resultClass.Reset(dc);
		dc->SetInternalFieldCount(1);

		Nan::SetMethod(target, "setSolutionName", setSolutionName);
		Nan::SetMethod(target, "setSolutionKey", setSolutionKey);
		Nan::SetMethod(target, "setOemLicenseKey", setOemLicenseKey);
		Nan::SetMethod(target, "recognize", recognize);
	}

	NODE_MODULE(ocrxpress, Init)

}

